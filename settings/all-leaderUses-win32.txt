vim: ft=leader:

..\QR.md:87:    <leader>tc          " (mapped to) ColorToggle (by colorizer) and files open fast when off
..\QR.md:377:<leader>atob " base64 to a string
..\QR.md:378:<leader>btoa " a string to base64
..\after\plugin\plugins.vim:31:noremap <leader>gg :call GitGutterFocus()<cr>
..\ftplugin\HashEqualsFolding.vim:19:vnoremap <buffer><leader>> :s/#=/#==/<CR>  " demote
..\ftplugin\HashEqualsFolding.vim:20:vnoremap <buffer><leader>< :s/#==/#=/<CR>  " promote
..\ftplugin\HashEqualsFolding.vim:42:nnoremap <buffer><leader><leader>> :call FirmComment('#')<cr>
..\ftplugin\HashEqualsFolding.vim:45:nnoremap <buffer><leader><leader>< :call FirmUnComment('#')<cr>
..\ftplugin\HashFolding.vim:10:vnoremap <buffer><leader>> :s/^#/##/<CR>
..\ftplugin\HashFolding.vim:12:vnoremap <buffer><leader>< :s/^#//<CR>
..\ftplugin\bbcode.vim:18:nnoremap <buffer> <leader><leader>] viwc[color=navy][/color]<Esc>bbp
..\ftplugin\bbcode.vim:21:vnoremap <buffer> <leader><leader>] c[color=navy][/color]<Esc>bbp
..\ftplugin\bbcode.vim:25:nnoremap <buffer> <leader>] viwc[code][/code]<Esc>bbp
..\ftplugin\bbcode.vim:28:vnoremap <buffer> <leader>] c[code][/code]<Esc>bbp
..\ftplugin\bbcode.vim:32:vnoremap <buffer> <leader>u c[url][/url]<Esc>F[PF]
..\ftplugin\bbcode.vim:38:nnoremap <buffer> <leader><leader>u viwc[user=][/user]<Esc>F[PF]
..\ftplugin\bbcode.vim:41:vnoremap <buffer> <leader><leader>u c[user=][/user]<Esc>F[PF]
..\ftplugin\emdr.vim:17:nnoremap <buffer> <leader><leader>= I━━  <Esc>A  ━━<Esc>
..\ftplugin\emdr.vim:20:nnoremap <buffer> <leader>== I━━<Esc>A━━<Esc>
..\ftplugin\emdr.vim:22:nnoremap <buffer> <leader>=- 0xx<Esc>$xx<Esc>
..\ftplugin\emdr.vim:24:nnoremap <buffer> <leader># 099i~<Esc>
..\ftplugin\dokuwiki.vim:13:vnoremap <buffer><leader>hh y:call PageTitleToHyperlink()<CR>
..\ftplugin\dokuwiki.vim:17:nnoremap <buffer> <leader>h :s/\(.\+\)  \(http.\+\)/[[\2 \|\1]]/<bar>noh<cr>
..\ftplugin\dokuwiki.vim:55:"   :unmap <leader>i
..\ftplugin\dokuwiki.vim:59:nnoremap <buffer> <leader><leader>i :s/\m\(^>\+\) /\1 <wrap indent> /<CR><Bar>A </wrap><Esc>
..\ftplugin\dokuwiki.vim:91:nnoremap <buffer> <leader>= I=<Esc>A=<Esc>
..\ftplugin\dokuwiki.vim:94:nnoremap <buffer> <leader><leader>= I=== <Esc>A ===<Esc>
..\ftplugin\dokuwiki.vim:98:nnoremap <leader><leader>5 ?''<cr>i<cr><esc>:s/''/%% /<cr>:s/''/ %%/<cr>kJ
..\ftplugin\dokuwiki.vim:101:nnoremap <buffer> <leader>' viwc''''<Esc>hP
..\ftplugin\dokuwiki.vim:104:vnoremap <buffer> <leader>' c''''<Esc>hP
..\ftplugin\fugitive.vim:6:nnoremap <buffer><leader>gp :Git push<cr>
..\ftplugin\fugitive.vim:7:nnoremap <buffer><leader>gs 4j-<cr>
..\ftplugin\gitconfig.vim:10:nnoremap <leader>u :s#https://github.com/#git@github.com:#g <CR>
..\ftplugin\lisp.vim:31:nnoremap <buffer><leader><leader>> :call FirmComment(';')<cr>
..\ftplugin\lisp.vim:34:nnoremap <buffer><leader><leader>< :call FirmUnComment(';')<cr>
..\ftplugin\lua.vim:9:vnoremap <buffer><leader>> :s/-- -/-- --/<CR>  " demote
..\ftplugin\lua.vim:10:vnoremap <buffer><leader>< :s/-- --/-- -/<CR>  " promote
..\ftplugin\markdown.vim:26:vnoremap <buffer><leader>> :s/^#/##/<CR>
..\ftplugin\markdown.vim:28:vnoremap <buffer><leader>< :s/^#//<CR>
..\ftplugin\markdown.vim:41:  nnoremap <buffer><leader>è viwc``<Esc>P
..\ftplugin\markdown.vim:43:  nnoremap <buffer><leader>` viwc``<Esc>P
..\ftplugin\markdown.vim:48:  vnoremap <buffer><leader>è c``<Esc>P
..\ftplugin\markdown.vim:50:  vnoremap <buffer><leader>` c``<Esc>P
..\ftplugin\md.vim:20:"  (I'm using <leader> here to avoid accidentally running this)
..\ftplugin\md.vim:22:  nnoremap <buffer><leader><leader><F7> :execute "silent !perl $misc/CP/PerlTools/MessengerMd.pl ".expand('%:p')<CR>
..\ftplugin\md.vim:24:  nnoremap <buffer><leader><leader><F7> :call MessengerMd()<CR>
..\ftplugin\md.vim:27:" check with  :map <leader><leader><F7>
..\ftplugin\md.vim:30:"  (I'm using <leader> here to avoid accidentally running this)
..\ftplugin\md.vim:32:  nnoremap <buffer><leader><F7> :execute "silent !perl $misc/CP/PerlTools/mysmsMD.pl ".expand('%:p')<CR>
..\ftplugin\md.vim:34:  nnoremap <buffer><leader><F7> :call MysmsMD()<CR>
..\ftplugin\md.vim:37:" check with  :map <leader><F7>
..\ftplugin\md.vim:45:vnoremap <buffer> <leader>v1 :s#^\v(.+)$#> \1  #g <bar> nohlsearch <CR>
..\ftplugin\md.vim:47:vnoremap <buffer> <leader>v2 :s#^\v(.+)  $\n^$#\1\r#g <CR>
..\ftplugin\perl.vim:10:nnoremap <leader>u :TagbarToggle<CR>
..\ftplugin\python.vim:10:nnoremap <leader>u :TagbarToggle<CR>
..\ftplugin\ps1.vim:17:" nnoremap <buffer><leader><leader>> :call FirmComment('#')<bar>%s/^# #endregion/#endregion/<bar>%s/^# #region/#region/<cr>:update<cr>:edit<cr>
..\ftplugin\ps1.vim:20:" nnoremap <buffer><leader><leader>< :call FirmUnComment('#')<cr>:update<cr>:edit<cr>
..\ftplugin\tex.vim:19:nnoremap <buffer><leader><F7> :call TabularFullAlign()<CR><Bar>:update<CR>
..\ftplugin\tex.vim:20:inoremap <buffer><leader><F7> <Esc>:call TabularFullAlign()<CR><Bar>:update<CR>
..\ftplugin\tex.vim:55:nnoremap <buffer><leader>> :call DemoteSubSections()<CR>
..\ftplugin\tex.vim:56:vnoremap <buffer><leader>> <Esc>:call DemoteSubSections()<CR>
..\ftplugin\tex.vim:67:nnoremap <buffer><leader>< :call PromoteSubSections()<CR>
..\ftplugin\tex.vim:68:vnoremap <buffer><leader>< <Esc>:call PromoteSubSections()<CR>
..\ftplugin\tex.vim:84:  nnoremap <silent><buffer><leader><F7> :call PHMatch()<cr>
..\ftplugin\tex.vim:85:  inoremap <silent><buffer><leader><F7> <Esc>:call PHMatch()<cr>
..\ftplugin\tex.vim:86:  vnoremap <silent><buffer><leader><F7> <Esc>:call PHMatch()<cr>
..\ftplugin\tex.vim:107:  nnoremap <silent><buffer><leader><F7> :call LaTeXsyntaxFolding()<cr>
..\ftplugin\tex.vim:108:  inoremap <silent><buffer><leader><F7> <Esc>:call LaTeXsyntaxFolding()<cr>
..\ftplugin\tex.vim:109:  vnoremap <silent><buffer><leader><F7> <Esc>:call LaTeXsyntaxFolding()<cr>
..\ftplugin\tex.vim:135:vnoremap <buffer> <leader>v1 :s#^\v(.+)$#\1 \\\\#g <bar> nohlsearch <CR>
..\ftplugin\tex.vim:137:vnoremap <buffer> <leader>v2 :s#^\v(.+) \\\\$\n^$#\1\r#g <CR>
..\grab\all.sh:24:echo 'grab uses of <leader>'
..\grab\all.sh:28:grep -ri --exclude-dir=grabbed -E '<leader>' ../* >> $of
..\ftplugin\vim.vim:36:vnoremap <buffer><leader>> :s/"">/"">>/<CR>
..\ftplugin\vim.vim:38:vnoremap <buffer><leader>< :s/"">>/"">/<CR>
..\ftplugin\vim.vim:44:nnoremap <buffer><leader><leader>> :call FirmComment('"')<cr>
..\ftplugin\vim.vim:47:nnoremap <buffer><leader><leader>< :call FirmUnComment('"')<cr>
..\grab\leader.ps1:11:'grab uses of <leader>'
..\grab\leader.ps1:16:pt '<leader>' .. >> $of
..\gvimrc.vim:41:nnoremap <leader>8 :call EightyTwoColumns()<cr>
..\pack\packs-cp\opt\MatchTagAlways\README.md:113:    nnoremap <leader>% :MtaJumpToOtherTag<cr>
..\pack\packs-cp\opt\colorizer\plugin\colorizer.vim:17:" By default, <leader>tc is mapped to ColorToggle. If you want to use another
..\pack\packs-cp\opt\fzf.vim\README.md:328:nmap <leader><tab> <plug>(fzf-maps-n)
..\pack\packs-cp\opt\fzf.vim\README.md:329:xmap <leader><tab> <plug>(fzf-maps-x)
..\pack\packs-cp\opt\fzf.vim\README.md:330:omap <leader><tab> <plug>(fzf-maps-o)
..\pack\packs-cp\opt\fzf.vim\doc\fzf-vim.txt:403:    nmap <leader><tab> <plug>(fzf-maps-n)
..\pack\packs-cp\opt\fzf.vim\doc\fzf-vim.txt:404:    xmap <leader><tab> <plug>(fzf-maps-x)
..\pack\packs-cp\opt\fzf.vim\doc\fzf-vim.txt:405:    omap <leader><tab> <plug>(fzf-maps-o)
..\pack\packs-cp\opt\listtoggle\README.md:10:    let g:lt_location_list_toggle_map = '<leader>l'
..\pack\packs-cp\opt\listtoggle\README.md:11:    let g:lt_quickfix_list_toggle_map = '<leader>q'
..\pack\packs-cp\opt\listtoggle\README.md:13:By default, they are set to `<leader>l` and `<leader>q`, respectively.
..\pack\packs-cp\opt\listtoggle\plugin\listtoggle.vim:28:      \ get( g:, 'lt_location_list_toggle_map', '<leader>l' )
..\pack\packs-cp\opt\listtoggle\plugin\listtoggle.vim:30:      \ get( g:, 'lt_quickfix_list_toggle_map', '<leader>q' )
..\pack\packs-cp\opt\listtoggle\plugin\listtoggle.vim:34:if g:lt_location_list_toggle_map != '<leader>l' ||
..\pack\packs-cp\opt\listtoggle\plugin\listtoggle.vim:35:      \ g:lt_quickfix_list_toggle_map != '<leader>q'
..\pack\packs-cp\opt\nerdcommenter\README.md:149:  * `[count]<leader>cc` **|NERDCommenterComment|**
..\pack\packs-cp\opt\nerdcommenter\README.md:153:  * `[count]<leader>cn` **|NERDCommenterNested|**
..\pack\packs-cp\opt\nerdcommenter\README.md:155:    Same as <leader>cc but forces nesting.
..\pack\packs-cp\opt\nerdcommenter\README.md:157:  * `[count]<leader>c<space>` **|NERDCommenterToggle|**
..\pack\packs-cp\opt\nerdcommenter\README.md:161:  * `[count]<leader>cm` **|NERDCommenterMinimal|**
..\pack\packs-cp\opt\nerdcommenter\README.md:165:  * `[count]<leader>ci` **|NERDCommenterInvert|**
..\pack\packs-cp\opt\nerdcommenter\README.md:169:  * `[count]<leader>cs` **|NERDCommenterSexy|**
..\pack\packs-cp\opt\nerdcommenter\README.md:173:  * `[count]<leader>cy` **|NERDCommenterYank|**
..\pack\packs-cp\opt\nerdcommenter\README.md:175:    Same as <leader>cc except that the commented line(s) are yanked first.
..\pack\packs-cp\opt\nerdcommenter\README.md:177:  * `<leader>c$` **|NERDCommenterToEOL|**
..\pack\packs-cp\opt\nerdcommenter\README.md:181:  * `<leader>cA` **|NERDCommenterAppend|**
..\pack\packs-cp\opt\nerdcommenter\README.md:189:  * `<leader>ca` **|NERDCommenterAltDelims|**
..\pack\packs-cp\opt\nerdcommenter\README.md:193:  * `[count]<leader>cl` **|NERDCommenterAlignLeft**
..\pack\packs-cp\opt\nerdcommenter\README.md:194:    `[count]<leader>cb` **|NERDCommenterAlignBoth**
..\pack\packs-cp\opt\nerdcommenter\README.md:196:    Same as **|NERDCommenterComment|** except that the delimiters are aligned down the left side (`<leader>cl`) or both sides (`<leader>cb`).
..\pack\packs-cp\opt\nerdcommenter\README.md:198:  * `[count]<leader>cu` **|NERDCommenterUncomment|**
..\pack\packs-cp\opt\nerdcommenter\README.md:206:nnoremap <silent> <leader>c} V}:call nerdcommenter#Comment('x', 'toggle')<CR>
..\pack\packs-cp\opt\nerdcommenter\README.md:207:nnoremap <silent> <leader>c{ V{:call nerdcommenter#Comment('x', 'toggle')<CR>
..\pack\packs-cp\opt\nerdcommenter\plugin\nerdcommenter.vim:73:                execute mode . 'map <leader>' . a:combo . ' ' . plug
..\pack\packs-cp\opt\nerdtree\README.markdown:113:nnoremap <leader>n :NERDTreeFocus<CR>
..\pack\packs-cp\opt\quick-scope\README.md:139:nmap <leader>q <plug>(QuickScopeToggle)
..\pack\packs-cp\opt\quick-scope\README.md:140:xmap <leader>q <plug>(QuickScopeToggle)
..\pack\packs-cp\opt\quick-scope\doc\quick-scope.txt:116:Create a custom mapping (<leader> + q in the example below):
..\pack\packs-cp\opt\quick-scope\doc\quick-scope.txt:118:  nmap <leader>q <plug>(QuickScopeToggle)
..\pack\packs-cp\opt\quick-scope\doc\quick-scope.txt:119:  xmap <leader>q <plug>(QuickScopeToggle)
..\pack\packs-cp\opt\tagalong.vim\autoload\tagalong.vim:23:      " e.g. {'c': '<leader>c'}
..\pack\packs-cp\opt\undotree\README.md:80:vim.keymap.set('n', '<leader><F5>', vim.cmd.UndotreeToggle)
..\pack\packs-cp\opt\vim-airline\autoload\airline\extensions\tabline\xtabline.vim:76:        call s:mapkeys('<leader><F5>','<Plug>XTablineToggleFiltering')
..\pack\packs-cp\opt\vim-airline\autoload\airline\extensions\tabline\xtabline.vim:80:        call s:mapkeys('<leader>tr','<Plug>XTablineReopen')
..\pack\packs-cp\opt\vim-airline\autoload\airline\extensions\tabline\xtabline.vim:102:        map <unique> <leader>cdc <Plug>XTablineCdCurrent
..\pack\packs-cp\opt\vim-airline\autoload\airline\extensions\tabline\xtabline.vim:103:        map <unique> <leader>cdd <Plug>XTablineCdDown1
..\pack\packs-cp\opt\vim-airline\autoload\airline\extensions\tabline\xtabline.vim:104:        map <unique> <leader>cd2 <Plug>XTablineCdDown2
..\pack\packs-cp\opt\vim-airline\autoload\airline\extensions\tabline\xtabline.vim:105:        map <unique> <leader>cd3 <Plug>XTablineCdDown3
..\pack\packs-cp\opt\vim-airline\autoload\airline\extensions\tabline\xtabline.vim:106:        map <unique> <leader>cdh <Plug>XTablineCdHome
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1199:  <leader>0 will jump to tenth buffer. Those mappings are not automatically
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1204:  nmap <leader>1 <Plug>AirlineSelectTab1
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1205:  nmap <leader>2 <Plug>AirlineSelectTab2
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1206:  nmap <leader>3 <Plug>AirlineSelectTab3
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1207:  nmap <leader>4 <Plug>AirlineSelectTab4
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1208:  nmap <leader>5 <Plug>AirlineSelectTab5
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1209:  nmap <leader>6 <Plug>AirlineSelectTab6
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1210:  nmap <leader>7 <Plug>AirlineSelectTab7
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1211:  nmap <leader>8 <Plug>AirlineSelectTab8
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1212:  nmap <leader>9 <Plug>AirlineSelectTab9
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1213:  nmap <leader>0 <Plug>AirlineSelectTab0
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1214:  nmap <leader>- <Plug>AirlineSelectPrevTab
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1215:  nmap <leader>+ <Plug>AirlineSelectNextTab
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1782:  nmap <leader><F5>  <Plug>XTablineToggleFiltering
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1786:  nmap <leader>tr    <Plug>XTablineReopen <SID>ReopenLastTab
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1816:  map <leader>cdc       <Plug>XTablineCdCurrent
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1817:  map <leader>cdd       <Plug>XTablineCdDown1
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1818:  map <leader>cd2       <Plug>XTablineCdDown2
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1819:  map <leader>cd3       <Plug>XTablineCdDown3
..\pack\packs-cp\opt\vim-airline\doc\airline.txt:1820:  map <leader>cdh       <Plug>XTablineCdHome
..\pack\packs-cp\opt\vim-base64\README.md:54:* `<leader>atob` to convert from base64 to a string
..\pack\packs-cp\opt\vim-base64\README.md:55:* `<leader>btoa` to convert from a string to base64
..\pack\packs-cp\opt\vim-base64\README.md:59:You can also, in normal mode, replace all instances of a regular expression by their base64 representation, using `<leader>btoa/` or `<leader>atob/`. This will insert a command mode string, with your cursor directly where you can type the regular expression.
..\pack\packs-cp\opt\vim-base64\doc\base64.txt:22:                                                        *debase64-<leader>-btoa*
..\pack\packs-cp\opt\vim-base64\doc\base64.txt:23:<leader>btoa            Base64 encodes the visually selected string
..\pack\packs-cp\opt\vim-base64\doc\base64.txt:25:                                                        *base64-<leader>-atob*
..\pack\packs-cp\opt\vim-base64\doc\base64.txt:26:<leader>atob            Decodes the visually selected base64 string
..\pack\packs-cp\opt\vim-base64\doc\base64.txt:28:                                                       *base64-<leader>-atob/*
..\pack\packs-cp\opt\vim-base64\doc\base64.txt:29:<leader>btoa/           Starts a command line for encoding a regex submatch
..\pack\packs-cp\opt\vim-base64\doc\base64.txt:31:                                                       *base64-<leader>-btoa/*
..\pack\packs-cp\opt\vim-base64\doc\base64.txt:32:<leader>atob/           Starts a command line for decoding a regex submatch
..\pack\packs-cp\opt\vim-base64\plugin\base64.vim:4:  vnoremap <silent> <leader>atob :<c-u>call base64#v_atob()<cr>
..\pack\packs-cp\opt\vim-base64\plugin\base64.vim:5:  vnoremap <silent> <leader>btoa :<c-u>call base64#v_btoa()<cr>
..\pack\packs-cp\opt\vim-base64\plugin\base64.vim:8:  nnoremap <leader>btoa/ :%s/\v()/\=base64#encode(submatch(1))/<home><right><right><right><right><right><right>
..\pack\packs-cp\opt\vim-base64\plugin\base64.vim:9:  nnoremap <leader>atob/ :%s/\v()/\=base64#decode(submatch(1))/<home><right><right><right><right><right><right>
..\pack\packs-cp\opt\vim-bufkill\README.md:63:" Turn off default <leader>bb, <leader>bd, etc. mappings (default: 1)
..\pack\packs-cp\opt\vim-closetag\README.md:101:let g:closetag_close_shortcut = '<leader>>'
..\pack\packs-cp\opt\vim-easy-align\test\include\setup.vader:24:  " nmap <leader>A <Plug>(EasyAlignOperator)
..\pack\packs-cp\opt\vim-easy-align\test\include\setup.vader:29:  vmap <leader><Enter> <Plug>(LiveEasyAlign)
..\pack\packs-cp\opt\vim-easy-align\test\include\setup.vader:30:  nmap <leader>A       <Plug>(EasyAlign)
..\pack\packs-cp\opt\vim-easy-align\test\include\setup.vader:31:  vmap <leader>.       <Plug>(EasyAlignRepeat)
..\pack\packs-cp\opt\vim-gitgutter\README.mkd:105:You can jump between hunks with `[c` and `]c`.  You can preview, stage, and undo hunks with `<leader>hp`, `<leader>hs`, and `<leader>hu` respectively.
..\pack\packs-cp\opt\vim-go\doc\vim-go.txt:958:  au FileType go nmap <leader>r <Plug>(go-run)
..\pack\packs-cp\opt\vim-go\doc\vim-go.txt:2854: au FileType go nmap <leader>rt <Plug>(go-run-tab)
..\pack\packs-cp\opt\vim-go\doc\vim-go.txt:2855: au FileType go nmap <leader>rs <Plug>(go-run-split)
..\pack\packs-cp\opt\vim-go\doc\vim-go.txt:2856: au FileType go nmap <leader>rv <Plug>(go-run-vertical)
..\pack\packs-cp\opt\vim-interestingwords\README.md:43:nnoremap <silent> <leader>k :call InterestingWords('n')<cr>
..\pack\packs-cp\opt\vim-interestingwords\README.md:44:vnoremap <silent> <leader>k :call InterestingWords('v')<cr>
..\pack\packs-cp\opt\vim-interestingwords\README.md:45:nnoremap <silent> <leader>K :call UncolorAllWords()<cr>
..\pack\packs-cp\opt\vim-interestingwords\plugin\interestingwords.vim:248:    nnoremap <silent> <leader>k :call InterestingWords('n')<cr>
..\pack\packs-cp\opt\vim-interestingwords\plugin\interestingwords.vim:249:    vnoremap <silent> <leader>k :call InterestingWords('v')<cr>
..\pack\packs-cp\opt\vim-interestingwords\plugin\interestingwords.vim:250:    nnoremap <silent> <leader>K :call UncolorAllWords()<cr>
..\pack\packs-cp\opt\vim-matchup\doc\matchup.txt:179:  nmap <leader>% <plug>(matchup-z%)
..\pack\packs-cp\opt\vim-peekaboo\README.md:35:| `g:peekaboo_prefix`     | Empty (string)  | Prefix for key mapping (e.g. `<leader>`)          |
..\pack\packs-cp\opt\vim-subversive\README.md:30:nmap <leader>s <plug>(SubversiveSubstituteRange)
..\pack\packs-cp\opt\vim-subversive\README.md:31:xmap <leader>s <plug>(SubversiveSubstituteRange)
..\pack\packs-cp\opt\vim-subversive\README.md:33:nmap <leader>ss <plug>(SubversiveSubstituteWordRange)
..\pack\packs-cp\opt\vim-subversive\README.md:36:After adding this map, if you execute `<leader>s<motion1><motion2>` then enter some text into a prompt in the status bar, then the text given by `motion1` should be replaced by the text we entered in the prompt for each line provided by `motion2`.  Alternatively, we can also select `motion1` in visual mode and then hit `<leader>s<motion2>` for the same effect.
..\pack\packs-cp\opt\vim-subversive\README.md:38:This can be very powerful. For example, you could execute `<leader>siwip` to replace all instances of the current word under the cursor that exist within the paragraph under the cursor.  Or `<leader>sl_` to replace all instances of the character under the cursor on the current line.
..\pack\packs-cp\opt\vim-subversive\README.md:40:The `<leader>ss` mapping is used as a shortcut to replace the current word under the cursor.  This allows you for example to execute `<leader>ssip` to replace the word under cursor in the current paragraph.  Note that this matches **complete** words so is different from `<leader>siwip` (which will not require that there be word boundaries on each match)
..\pack\packs-cp\opt\vim-subversive\README.md:46:In this gif, we first rename the local `foo` parameter by executing `<leader>ssom` then entering `bar` in the prompt (note that `om` is a custom motion that stands for 'outer c# method' and is not provided by this plugin).  Also note that because we are using `<leader>ss`, the text `_foos` is unaffected because it does not match the complete word.  It is useful in this case because we only want to rename the parameter within the function.
..\pack\packs-cp\opt\vim-subversive\README.md:48:After that we switch to visual mode and select the `foo` part `_foos` then execute `<leader>sie` and once again enter `bar` into the prompt.  `ie` is again a custom motion that stands for `entire buffer` (see next section for details)
..\pack\packs-cp\opt\vim-subversive\README.md:50:After that we move to the `Foo` part of `AddFoo` and execute `<leader>seie` and once again enter `Bar`.  Then finally do the same for the fully capitalized `FOOS`.
..\pack\packs-cp\opt\vim-subversive\README.md:54:Note also that this motion is repeatable.  If you run `<leader>siwip` in one paragraph, then go to a different paragraph, then hit `.` then the same substitution will apply to the new paragraph under the cursor.
..\pack\packs-cp\opt\vim-subversive\README.md:77:nmap <leader>cs <plug>(SubversiveSubstituteRangeConfirm)
..\pack\packs-cp\opt\vim-subversive\README.md:78:xmap <leader>cs <plug>(SubversiveSubstituteRangeConfirm)
..\pack\packs-cp\opt\vim-subversive\README.md:79:nmap <leader>css <plug>(SubversiveSubstituteWordRangeConfirm)
..\pack\packs-cp\opt\vim-subversive\README.md:82:These work the same as the `<leader>s` maps above except will step through each replacement one by one.
..\pack\packs-cp\opt\vim-subversive\README.md:88:    If you provide an explicit register to any of the substitute motions above it will not prompt and instead will use the contents of the given register.  For example, `"a<leader>siwip` will immediately replace all instances of the current word under the cursor with the contents of register `a` that exist within the current paragraph.
..\pack\packs-cp\opt\vim-subversive\README.md:93:    nmap <leader>s <plug>(SubversiveSubstituteRangeNoPrompt)
..\pack\packs-cp\opt\vim-subversive\README.md:94:    xmap <leader>s <plug>(SubversiveSubstituteRangeNoPrompt)
..\pack\packs-cp\opt\vim-subversive\README.md:96:    nmap <leader>ss <plug>(SubversiveSubstituteWordRangeNoPrompt)
..\pack\packs-cp\opt\vim-subversive\README.md:103:    You can do this by passing the black hole register to one of the substitute over range commands. For example: `"_<leader>siwip` or `"_<leader>csiwip` if you want to confirm each delete.
..\pack\packs-cp\opt\vim-subversive\README.md:119:nmap <leader><leader>s <plug>(SubversiveSubvertRange)
..\pack\packs-cp\opt\vim-subversive\README.md:120:xmap <leader><leader>s <plug>(SubversiveSubvertRange)
..\pack\packs-cp\opt\vim-subversive\README.md:122:nmap <leader><leader>ss <plug>(SubversiveSubvertWordRange)
..\pack\packs-cp\opt\vim-subversive\README.md:125:This will behave the same as `<leader>s` except that it will perform an abolish 'subvert' instead of using vim's built in substitute command.  This will apply the substitution and also preserve whatever case the original word has.  For example:
..\pack\packs-cp\opt\vim-subversive\README.md:129:In this case, we move the cursor overtop `foo` and then execute `<leader><leader>seie` then enter `bar`, which replaces all instances of `foo` regardless of case.
..\pack\packs-cp\opt\vim-subversive\README.md:133:As you would expect, the `<leader><leader>ss` mapping works similarly except only matches complete words that include word boundaries.
..\pack\packs-cp\opt\vim-subversive\README.md:138:nmap <leader><leader>s <plug>(SubversiveSubvertRangeNoPrompt)
..\pack\packs-cp\opt\vim-subversive\README.md:139:xmap <leader><leader>s <plug>(SubversiveSubvertRangeNoPrompt)
..\pack\packs-cp\opt\vim-subversive\README.md:141:nmap <leader><leader>ss <plug>(SubversiveSubvertWordRangeNoPrompt)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:29:    nmap <leader>s <plug>(SubversiveSubstituteRange)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:30:    xmap <leader>s <plug>(SubversiveSubstituteRange)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:32:    nmap <leader>ss <plug>(SubversiveSubstituteWordRange)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:34:After adding this map, if you execute '<leader>s<motion1><motion2>' then enter some text into a prompt in the status bar, then the text given by 'motion1' should be replaced by the text we entered in the prompt for each line provided by 'motion2'.  Alternatively, we can also select 'motion1' in visual mode and then hit '<leader>s<motion2>' for the same effect.
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:36:This can be very powerful. For example, you could execute '<leader>siwip' to replace all instances of the current word under the cursor that exist within the paragraph under the cursor.  Or '<leader>sl_' to replace all instances of the character under the cursor on the current line.
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:38:The '<leader>ss' mapping is used as a shortcut to replace the current word under the cursor.  This allows you for example to execute '<leader>ssip' to replace the word under cursor in the current paragraph.  Note that this matches complete words so is different from '<leader>siwip' (which will not require that there be word boundaries on each match)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:42:In this gif, we first rename the local 'foo' parameter by executing '<leader>ssom' then entering 'bar' in the prompt (note that 'om' is a custom motion that stands for 'outer c# method' and is not provided by this plugin).  Also note that because we are using '<leader>ss', the text '_foos' is unaffected because it does not match the complete word.  It is useful in this case because we only want to rename the parameter within the function.
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:44:After that we switch to visual mode and select the 'foo' part '_foos' then execute '<leader>sie' and once again enter 'bar' into the prompt.  `ie` is again a custom motion that stands for `entire buffer` (see next section for details)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:46:After that we move to the 'Foo' part of 'AddFoo' and execute '<leader>seie' and once again enter 'Bar'.  Then finally do the same for the fully capitalized 'FOOS'.
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:62:If you provide an explicit register to any of the substitute motions above it will not prompt and instead will use the contents of the given register.  For example, '"a<leader>siwip' will immediately replace all instances of the current word under the cursor with the contents of register 'a' that exist within the current paragraph.
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:66:    nmap <leader>s <plug>(SubversiveSubstituteRangeNoPrompt)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:67:    xmap <leader>s <plug>(SubversiveSubstituteRangeNoPrompt)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:69:    nmap <leader>ss <plug>(SubversiveSubstituteWordRangeNoPrompt)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:77:    nmap <leader>cr <plug>(SubversiveSubstituteRangeConfirm)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:78:    xmap <leader>cr <plug>(SubversiveSubstituteRangeConfirm)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:79:    nmap <leader>crr <plug>(SubversiveSubstituteWordRangeConfirm)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:81:These work the same as the '<leader>r' maps above except will step through each replacement one by one.
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:92:    nmap <leader><leader>s <plug>(SubversiveSubvertRange)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:93:    xmap <leader><leader>s <plug>(SubversiveSubvertRange)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:95:    nmap <leader><leader>ss <plug>(SubversiveSubvertWordRange)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:97:This will behave the same as '<leader>s' except that it will perform an abolish 'subvert' instead of using vim's built in substitute command.  This will apply the substitution and also preserve whatever case the original word has.  For example:
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:101:In this example, we move the cursor overtop 'foo' and then execute '<leader><leader>seie' then enter 'bar', which replaces all instances of 'foo' regardless of case.
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:105:As you would expect, the '<leader><leader>ss' mapping works similarly except only matches complete words that include word boundaries.
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:109:    nmap <leader><leader>s <plug>(SubversiveSubvertRangeNoPrompt)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:110:    xmap <leader><leader>s <plug>(SubversiveSubvertRangeNoPrompt)
..\pack\packs-cp\opt\vim-subversive\doc\subversive.txt:112:    nmap <leader><leader>ss <plug>(SubversiveSubvertWordRangeNoPrompt)
..\pack\packs-cp\opt\vim-visual-star-search\README.md:17:If you hit `<leader>*` (`\*` unless you changed the mapleader), vim
..\pack\packs-cp\opt\vim-visual-star-search\README.md:20:If you have already mapped `<leader>*` then visual star search won't override it.
..\pack\packs-cp\opt\vim-visual-star-search\test-patterns:3:recursive search (<leader>*), and see if Vim finds
..\pack\packs-cp\opt\vim-visual-star-search\plugin\visual-star-search.vim:25:if maparg('<leader>*', 'n') == ''
..\pack\packs-cp\opt\vim-visual-star-search\plugin\visual-star-search.vim:26:  nnoremap <leader>* :execute 'noautocmd vimgrep /\V' . substitute(escape(expand("<cword>"), '\'), '\n', '\\n', 'g') . '/ **'<CR>
..\pack\packs-cp\opt\vim-visual-star-search\plugin\visual-star-search.vim:28:if maparg('<leader>*', 'v') == ''
..\pack\packs-cp\opt\vim-visual-star-search\plugin\visual-star-search.vim:29:  vnoremap <leader>* :<C-u>call VisualStarSearchSet('/')<CR>:execute 'noautocmd vimgrep /' . @/ . '/ **'<CR>
..\pack\packs-unix\opt\vim-better-whitespace\doc\better-whitespace.txt:86:By default, an operator is provided mapped to: <leader>s.
..\pack\packs-unix\opt\vim-better-whitespace\README.md:87:    *  There is an operator (defaulting to `<leader>s`) to clean whitespace.
..\pack\packs-unix\opt\vim-better-whitespace\README.md:88:        For example, in normal mode, `<leader>sip` will remove trailing whitespace from the
..\pack\packs-unix\opt\vim-better-whitespace\plugin\better-whitespace.vim:23:call s:InitVariable('better_whitespace_operator', '<leader>s')
..\pack\packs-unix\opt\vim-picker\README.md:114:nmap <unique> <leader>pe <Plug>(PickerEdit)
..\pack\packs-unix\opt\vim-picker\README.md:115:nmap <unique> <leader>ps <Plug>(PickerSplit)
..\pack\packs-unix\opt\vim-picker\README.md:116:nmap <unique> <leader>pt <Plug>(PickerTabedit)
..\pack\packs-unix\opt\vim-picker\README.md:117:nmap <unique> <leader>pd <Plug>(PickerTabdrop)
..\pack\packs-unix\opt\vim-picker\README.md:118:nmap <unique> <leader>pv <Plug>(PickerVsplit)
..\pack\packs-unix\opt\vim-picker\README.md:119:nmap <unique> <leader>pb <Plug>(PickerBuffer)
..\pack\packs-unix\opt\vim-picker\README.md:120:nmap <unique> <leader>p] <Plug>(PickerTag)
..\pack\packs-unix\opt\vim-picker\README.md:121:nmap <unique> <leader>pw <Plug>(PickerStag)
..\pack\packs-unix\opt\vim-picker\README.md:122:nmap <unique> <leader>po <Plug>(PickerBufferTag)
..\pack\packs-unix\opt\vim-picker\README.md:123:nmap <unique> <leader>ph <Plug>(PickerHelp)
..\plugin\plugin.vim:46:nnoremap <leader>sb :buffers<CR>:sbuffer<Space>
..\plugin\plugin.vim:65:  nnoremap <leader>é :call ClearFancyGlyphs()<cr>
..\plugin\plugin.vim:67:  nnoremap <leader>2 :call ClearFancyGlyphs()<cr>
..\plugin\plugin.vim:107:nnoremap <leader><leader>2 :call ClearMAS()<cr>
..\plugin\plugin.vim:177:    noremap <leader>yp :lan fr_FR.UTF-8<CR>:pu=strftime('%a %d %b %Y')<CR>:lan en_GB.UTF-8<CR>:s/\.//g<cr>:noh<cr>
..\plugin\plugin.vim:179:    noremap <leader>yp :lan en_GB.UTF-8<CR>:pu=strftime('%a %d %b %Y')<CR>:lan fr_FR.UTF-8<CR>
..\plugin\plugin.vim:183:    noremap <leader>yp :lan tim English_United Kingdom<CR>:pu=strftime('%a %d %b %Y')<CR>:lan tim French<CR>
..\plugin\plugin.vim:185:    noremap <leader>yp :lan tim French<CR>:pu=strftime('%a %d %b %Y')<CR>:lan tim English_United Kingdom<CR>:s/\.//g<cr>:noh<cr>
..\plugin\plugin.vim:208:nnoremap <leader>9 :call PercentUnicode()<cr>
..\plugin\plugin.vim:247:  nnoremap <leader>( :call UnicodePercent()<cr>
..\plugin\plugin.vim:249:  nnoremap <leader>5 :call UnicodePercent()<cr>
..\plugin\plugin.vim:287:  nnoremap <leader><leader>( :s/\m\[.\{-}]//g<CR>
..\plugin\plugin.vim:289:  nnoremap <leader>[ :s/\m\[.\{-}]//g<CR>
..\plugin\plugin.vim:316:nnoremap <leader>U :Underline
..\plugin\plugin.vim:420:nnoremap <leader>vn :vnew<CR>
..\plugin\plugin.vim:424:inoremap <leader><f5> :call clearmatches()<cr>
..\plugin\plugin.vim:425:nnoremap <leader><f5> :call clearmatches()<cr>
..\plugin\plugin.vim:436:nnoremap <silent><leader>rn :set rnu! rnu? <CR>
..\plugin\plugin.vim:496:nnoremap <leader>n :nohlsearch<CR>
..\plugin\plugin.vim:497:vnoremap <leader>n <Esc>:nohlsearch<CR>
..\plugin\plugin.vim:508:nnoremap <leader>/ :call TweakLS()<CR>
..\plugin\plugin.vim:523:nnoremap <leader>vg :call VimgrepSelection()<CR>
..\plugin\plugin.vim:533:nnoremap <leader><leader>q :call VimgrepQRs()<CR>
..\plugin\plugin.vim:542:nnoremap <leader>is :call IncSearchToggle()<cr>
..\plugin\plugin.vim:560:" and <leader>pt toggles it:
..\plugin\plugin.vim:561:nnoremap <leader>pt :call ParenthsToggle()<cr>
..\plugin\plugin.vim:577:" noremap <leader>q :copen<CR>
..\plugin\plugin.vim:590:nnoremap <leader>vs :call ConvertSearchForVisualSelection()<CR>
..\plugin\plugin.vim:591:vnoremap <leader>vs <Esc>:call ConvertSearchForVisualSelection()<CR>
..\plugin\plugin.vim:596:  nnoremap <leader>v v$hy
..\plugin\plugin.vim:600:nnoremap <leader>f :let@f=@%<CR>
..\plugin\plugin.vim:603:nnoremap <silent><leader><F11> :echo strftime('%c',getftime(expand('%')))<cr>
..\plugin\plugin.vim:604:inoremap <silent><leader><F11> <Esc>:echo strftime('%c',getftime(expand('%')))<cr>
..\plugin\plugin.vim:605:vnoremap <silent><leader><F11> <Esc>:echo strftime('%c',getftime(expand('%')))<cr>
..\plugin\plugin.vim:610:nnoremap <leader>- :Hexplore<cr>
..\plugin\plugin.vim:617:nnoremap <leader>d :cd %:p:h<CR>:pwd<CR>
..\plugin\plugins.vim:288:" <leader>c<space> -> NERDCommenterToggle
..\plugin\plugins.vim:297:" add this for relevant filetypes:  nnoremap <silent> <buffer> <leader>ct :TagbarToggle<CR>
..\plugin\plugins.vim:314:nnoremap <leader>pp :<c-u>MatchupWhereAmI??<cr>
..\plugin\plugins.vim:325:nnoremap <leader>B :BLines<CR>
..\plugin\plugins.vim:326:nnoremap <leader>L :Lines<CR>
..\plugin\plugins.vim:327:nnoremap <leader>bf :Buffers<CR>
..\plugin\plugins.vim:348:  nnoremap <leader>j :Files /mnt/BX200/Dropbox/JH<CR>
..\plugin\plugins.vim:350:  nnoremap <leader>j :Files /mnt/SDEP128G/Dropbox/JH<CR>
..\plugin\plugins.vim:352:  nnoremap <leader>j :Files /mnt/SDU3D1TB/Dropbox/JH<CR>
..\plugin\plugins.vim:354:  nnoremap <leader>j :Files C:\Users\jharr\Dropbox\JH<CR>
..\plugin\plugins.vim:356:  nnoremap <leader>j :Files C:\Users\troin\Dropbox\JH<CR>
..\plugin\plugins.vim:390:" noremap <leader>aa :ALEToggleBuffer<CR>  " doesn't report status
..\plugin\plugins.vim:391:noremap <leader>aa :call ALEToggleBufferShow()<cr>
..\plugin\plugins.vim:411:nnoremap <leader>th :ThesaurusQueryReplaceCurrentWord<CR>
..\plugin\plugins.vim:415:nnoremap <leader>lt :LangTool <bar> lopen 15 <CR>
..\plugin\plugins.vim:423:nnoremap <leader>LT :call LanguageTool_lopen() <CR>
..\plugin\plugins.vim:490:nnoremap <silent><leader>it :call IlluminateMoreToggle()<cr>
..\plugin\plugins.vim:547:noremap <leader>yy :CalendarH<CR>
..\plugin\plugins.vim:563:nnoremap <leader>bb :CtrlPBuffer<CR>
..\plugin\plugins.vim:616:  nnoremap <leader>m :MRU
..\plugin\plugins.vim:619:  nnoremap <leader>m :MRU<CR>
..\plugin\plugins.vim:697:  nmap <unique> <leader>pe <Plug>(PickerEdit)
..\plugin\plugins.vim:698:  nmap <unique> <leader>pb <Plug>(PickerBuffer)
..\plugin\plugins.vim:778:nnoremap <leader>e :call EasyMotionSearchToggle()<cr>
..\plugin\plugins.vim:803:nmap <leader><leader>m <Plug>MarkSet
..\plugin\plugins.vim:804:nmap <leader><leader>n <Plug>MarkClear
..\plugin\plugins.vim:825:nmap <leader>s <plug>(SubversiveSubstituteRangeConfirm)
..\plugin\plugins.vim:850:noremap <silent> <leader>be :BufExplorer<CR>
..\plugin\plugins.vim:863:nnoremap <leader>bdd :Bdelete other<CR>
..\plugin\plugins.vim:865:nnoremap <leader>bd  :Bdelete hidden<CR>
..\plugin\plugins.vim:882:noremap <silent> <leader>dd :BD<CR>
..\plugin\plugins.vim:893:let g:lt_location_list_toggle_map = '<leader>ll'
..\plugin\plugins.vim:897:" let g:lt_location_list_toggle_map = '<leader>l'
..\plugin\plugins.vim:898:" let g:lt_quickfix_list_toggle_map = '<leader>q'
..\syntax\leader.vim:14:syn match leader '<leader>\c' nextgroup=keystrokes
..\vimrc.vim:65:noremap <leader><leader>ll :set list! list? <CR>  " (:h 'list')
..\vimrc.vim:70:nnoremap <leader>x <C-W>c
..\vimrc.vim:81:nnoremap <silent><leader><leader>c :set cuc! cuc? <CR>
..\vimrc.vim:83:nnoremap <silent><leader><leader>l :set cul! cul? <CR>
..\vimrc.vim:139:nnoremap <leader><down> 5<C-W>-
..\vimrc.vim:141:nnoremap <leader><up> 5<C-W>+
..\vimrc.vim:143:nnoremap <leader><left> 10<C-W><
..\vimrc.vim:145:nnoremap <leader><right> 10<C-W>>
..\vimrc.vim:147:nnoremap <leader>c= :windo set nowfh <CR>
